#!/usr/bin/env python3

"""
llmlog - A formatter for LLM chat session logs.

Reads JSONL log files (currently OpenCode format) and outputs formatted,
colorized text suitable for viewing with less -R, nvim, bat, etc.

Usage:
    llmlog <file.jsonl> [options] | less -R
    llmlog <session-title> [options] | less -R
    llmlog <file.jsonl> --viewer=nvim | nvim -R -

Options:
    --format=FORMAT     Input format: opencode (default: opencode)
    --output=FORMAT     Output format: ansi, markdown (default: ansi)
    --tools=MODE        Tool display: summary, expand, hide (default: summary)
    --viewer=VIEWER     Viewer hints: less, nvim (default: less)
    --no-color          Disable ANSI colors
    --list              List available sessions for current directory
    -h, --help          Show this help message
"""

import argparse
import glob
import json
import os
import signal
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional, TextIO

signal.signal(signal.SIGPIPE, signal.SIG_DFL)

LOGS_ROOT = Path.home() / ".local" / "share" / "opencode" / "logs"


def get_log_dir_for_cwd() -> Path:
    """Get the log directory corresponding to the current working directory."""
    cwd = os.getcwd()
    sanitized = cwd.lstrip("/").replace("/", "-")
    return LOGS_ROOT / sanitized


def resolve_session_file(file_arg: str) -> Optional[str]:
    """
    Resolve a file argument to a full path.
    
    If it's already a valid path, return it.
    Otherwise, try to find a matching session in the current directory's log folder.
    """
    # If it's already a valid file path, use it directly
    if os.path.isfile(file_arg):
        return file_arg
    
    # Try to find it in the log directory for current working directory
    log_dir = get_log_dir_for_cwd()
    if not log_dir.is_dir():
        return None
    
    # Look for exact match first
    exact_match = log_dir / file_arg
    if exact_match.is_file():
        return str(exact_match)
    
    # Try with .jsonl extension
    with_ext = log_dir / f"{file_arg}.jsonl"
    if with_ext.is_file():
        return str(with_ext)
    
    # Try partial match on session title (after the session ID prefix)
    pattern = f"*-{file_arg}*.jsonl"
    matches = list(log_dir.glob(pattern))
    if len(matches) == 1:
        return str(matches[0])
    elif len(matches) > 1:
        print(f"Error: Ambiguous session name '{file_arg}'. Matches:", file=sys.stderr)
        for m in matches:
            print(f"  {m.name}", file=sys.stderr)
        sys.exit(1)
    
    # Try even looser match
    pattern = f"*{file_arg}*.jsonl"
    matches = list(log_dir.glob(pattern))
    if len(matches) == 1:
        return str(matches[0])
    elif len(matches) > 1:
        print(f"Error: Ambiguous session name '{file_arg}'. Matches:", file=sys.stderr)
        for m in matches:
            print(f"  {m.name}", file=sys.stderr)
        sys.exit(1)
    
    return None


def list_sessions() -> None:
    """List available sessions for the current directory."""
    log_dir = get_log_dir_for_cwd()
    if not log_dir.is_dir():
        print(f"No logs found for current directory.", file=sys.stderr)
        print(f"Expected log directory: {log_dir}", file=sys.stderr)
        sys.exit(1)
    
    sessions = sorted(log_dir.glob("*.jsonl"), key=lambda p: p.stat().st_mtime, reverse=True)
    if not sessions:
        print("No session logs found.", file=sys.stderr)
        sys.exit(1)
    
    print(f"Sessions in {log_dir}:\n")
    for s in sessions:
        name = s.name
        # Extract title (remove session ID prefix and .jsonl suffix)
        parts = name.split("-", 1)
        title = parts[1].rsplit(".jsonl", 1)[0] if len(parts) > 1 else name
        mtime = datetime.fromtimestamp(s.stat().st_mtime).strftime("%Y-%m-%d %H:%M")
        print(f"  {mtime}  {title}")



class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    ITALIC = "\033[3m"

    BLACK = "\033[30m"
    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    MAGENTA = "\033[35m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"

    BG_BLACK = "\033[40m"
    BG_RED = "\033[41m"
    BG_GREEN = "\033[42m"
    BG_YELLOW = "\033[43m"
    BG_BLUE = "\033[44m"
    BG_MAGENTA = "\033[45m"
    BG_CYAN = "\033[46m"
    BG_WHITE = "\033[47m"

    BRIGHT_BLACK = "\033[90m"
    BRIGHT_RED = "\033[91m"
    BRIGHT_GREEN = "\033[92m"
    BRIGHT_YELLOW = "\033[93m"
    BRIGHT_BLUE = "\033[94m"
    BRIGHT_MAGENTA = "\033[95m"
    BRIGHT_CYAN = "\033[96m"
    BRIGHT_WHITE = "\033[97m"


class NoColors:
    def __getattr__(self, name):
        return ""


class Formatter:
    def __init__(self, use_color: bool = True, tools_mode: str = "summary",
                 viewer: str = "less", output_format: str = "ansi"):
        self.c = Colors() if use_color else NoColors()
        self.tools_mode = tools_mode
        self.viewer = viewer
        self.output_format = output_format

    def format_separator(self, role: str, timestamp: str) -> str:
        width = 80
        role_upper = role.upper()

        if role == "user":
            role_color = f"{self.c.BOLD}{self.c.BRIGHT_GREEN}"
        elif role == "assistant":
            role_color = f"{self.c.BOLD}{self.c.BRIGHT_BLUE}"
        else:
            role_color = f"{self.c.BOLD}{self.c.WHITE}"

        ts_formatted = self.format_timestamp(timestamp)
        header = f"{role_color}{role_upper}{self.c.RESET} {self.c.DIM}│{self.c.RESET} {self.c.BRIGHT_BLACK}{ts_formatted}{self.c.RESET}"

        sep_line = f"{self.c.DIM}{'━' * width}{self.c.RESET}"

        return f"\n{sep_line}\n{header}\n{sep_line}\n"

    def format_timestamp(self, timestamp: str) -> str:
        if not timestamp:
            return ""
        try:
            dt = datetime.fromisoformat(timestamp.replace("Z", "+00:00"))
            return dt.strftime("%Y-%m-%d %H:%M:%S")
        except (ValueError, AttributeError):
            return timestamp

    def format_text(self, text: str) -> str:
        return f"\n{text}\n"

    def format_tool_summary(self, tool_name: str, input_preview: str) -> str:
        preview = input_preview[:60] + "..." if len(input_preview) > 60 else input_preview
        preview = preview.replace("\n", " ")
        return f"\n{self.c.DIM}[{self.c.RESET}{self.c.YELLOW}Tool: {tool_name}{self.c.RESET}{self.c.DIM}]{self.c.RESET} {self.c.BRIGHT_BLACK}{preview}{self.c.RESET}\n"

    def format_tool_expanded(self, tool_name: str, tool_state: dict) -> str:
        lines = []

        if self.viewer == "nvim":
            lines.append(f"\n{self.c.DIM}{{{{{{" + f" Tool: {tool_name}{self.c.RESET}")
        else:
            lines.append(f"\n{self.c.DIM}┌─ {self.c.RESET}{self.c.YELLOW}{self.c.BOLD}Tool: {tool_name}{self.c.RESET}")

        input_data = tool_state.get("input", {})
        if isinstance(input_data, dict):
            for key, value in input_data.items():
                value_str = str(value)
                if len(value_str) > 200:
                    value_str = value_str[:200] + "..."
                value_str = value_str.replace("\n", "\\n")
                lines.append(f"{self.c.DIM}│{self.c.RESET} {self.c.CYAN}{key}:{self.c.RESET} {value_str}")
        elif input_data:
            lines.append(f"{self.c.DIM}│{self.c.RESET} {self.c.CYAN}input:{self.c.RESET} {input_data}")

        output = tool_state.get("output", "")
        if output:
            output_preview = str(output)[:300]
            if len(str(output)) > 300:
                output_preview += "..."
            output_lines = output_preview.split("\n")
            lines.append(f"{self.c.DIM}│{self.c.RESET}")
            lines.append(f"{self.c.DIM}│{self.c.RESET} {self.c.GREEN}Output:{self.c.RESET}")
            for out_line in output_lines[:10]:
                lines.append(f"{self.c.DIM}│{self.c.RESET}   {self.c.BRIGHT_BLACK}{out_line}{self.c.RESET}")
            if len(output_lines) > 10:
                lines.append(f"{self.c.DIM}│{self.c.RESET}   {self.c.BRIGHT_BLACK}... ({len(output_lines) - 10} more lines){self.c.RESET}")
        else:
            lines.append(f"{self.c.DIM}│{self.c.RESET} {self.c.GREEN}Output:{self.c.RESET} {self.c.BRIGHT_BLACK}(empty){self.c.RESET}")

        if self.viewer == "nvim":
            lines.append(f"{self.c.DIM}}}}}}}{self.c.RESET}")
        else:
            lines.append(f"{self.c.DIM}└─{self.c.RESET}")

        return "\n".join(lines) + "\n"

    def format_tool(self, part: dict) -> str:
        if self.tools_mode == "hide":
            return ""

        tool_name = part.get("tool", "unknown")
        tool_state = part.get("state", {})

        if self.tools_mode == "summary":
            input_data = tool_state.get("input", {})
            if isinstance(input_data, dict):
                preview = input_data.get("command", input_data.get("description", str(input_data)))
            else:
                preview = str(input_data)
            return self.format_tool_summary(tool_name, preview)
        else:
            return self.format_tool_expanded(tool_name, tool_state)

    def format_message(self, entry: dict) -> str:
        if entry.get("type") != "message":
            return ""

        role = entry.get("role", "unknown")
        timestamp = entry.get("timestamp", "")
        parts = entry.get("parts", [])

        output = []
        output.append(self.format_separator(role, timestamp))

        for part in parts:
            part_type = part.get("type", "")

            if part_type == "text":
                text = part.get("text", "")
                if text:
                    output.append(self.format_text(text))

            elif part_type == "tool":
                output.append(self.format_tool(part))

            # Skip step-start, step-finish, and other metadata types

        return "".join(output)


def process_opencode_log(file: TextIO, formatter: Formatter) -> None:
    for line in file:
        line = line.strip()
        if not line:
            continue

        try:
            entry = json.loads(line)
        except json.JSONDecodeError:
            continue

        if entry.get("type") == "message":
            output = formatter.format_message(entry)
            if output:
                print(output, end="")


def main():
    parser = argparse.ArgumentParser(
        description="Format LLM chat session logs for viewing",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    llmlog session.jsonl | less -R
    llmlog my-feature --tools=expand | less -R
    llmlog session.jsonl --viewer=nvim | nvim -R -
    llmlog --list
        """
    )

    parser.add_argument("file", nargs="?", help="JSONL log file or session name (default: stdin)")
    parser.add_argument("--list", "-l", dest="list_sessions", action="store_true",
                        help="List available sessions for current directory")
    parser.add_argument("--format", dest="input_format", default="opencode",
                        choices=["opencode"],
                        help="Input format (default: opencode)")
    parser.add_argument("--output", dest="output_format", default="ansi",
                        choices=["ansi", "markdown"],
                        help="Output format (default: ansi)")
    parser.add_argument("--tools", dest="tools_mode", default="summary",
                        choices=["summary", "expand", "hide"],
                        help="Tool call display mode (default: summary)")
    parser.add_argument("--viewer", default="less",
                        choices=["less", "nvim"],
                        help="Target viewer hints (default: less)")
    parser.add_argument("--no-color", dest="no_color", action="store_true",
                        help="Disable ANSI colors")

    args = parser.parse_args()

    if args.list_sessions:
        list_sessions()
        return

    use_color = not args.no_color
    if args.viewer == "nvim":
        use_color = False

    formatter = Formatter(
        use_color=use_color,
        tools_mode=args.tools_mode,
        viewer=args.viewer,
        output_format=args.output_format
    )

    if args.file:
        resolved_file = resolve_session_file(args.file)
        if resolved_file is None:
            print(f"Error: Could not find session: {args.file}", file=sys.stderr)
            print(f"Use 'llmlog --list' to see available sessions.", file=sys.stderr)
            sys.exit(1)
        try:
            with open(resolved_file, "r", encoding="utf-8") as f:
                process_opencode_log(f, formatter)
        except FileNotFoundError:
            print(f"Error: File not found: {resolved_file}", file=sys.stderr)
            sys.exit(1)
        except PermissionError:
            print(f"Error: Permission denied: {resolved_file}", file=sys.stderr)
            sys.exit(1)
    else:
        process_opencode_log(sys.stdin, formatter)


if __name__ == "__main__":
    main()
